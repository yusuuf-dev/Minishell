// fix old/a.out: executing a file by it's relative path doesn't work if the file is in a dir
// check if the builtin functions work properly
// fix the ~{user} ex: ~asoufian
// make the code more readable, 
// store all the needed variables in a struct
// symbolik links !!!!!!! : CD AND PWD
// echo "test something" needs to be handled
- to get the actual output of a command run 'set -x' to unset it run 'set +x'
/*
export:
variables:
	A word consisting solely of letters, numbers, and underscores, and beginning with a letter or underscore. 
	Names are used as shell variable and function names. Also referred to as an identifier.
    also look up if the x-declare in the export means anything
    if I readonly an env variable it becomes declare -rx in the export 
  maybe I should remove the variable '_' since the minishell doesn't update it and the bash doesn't seem to give it the 'x' attribute
  export --help, what does 'export --' do ??

revisit all built-in functions !!!!!!!!!!!
*/
/* Parsing:
    handle the '#' as in echo #test .... : MAYBE ??????????????????????????????????????????????????
    the shell ignores the comment symbol (‘#’), and the rest of that line. */
    /*minishell : export test=something
    minishell : echo testing$test
    testing$test
    echo "$PATH"test
    echo $'\n'
    x=-n
    echo $x $PATH $: /home/asoufian/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin%
  *  old/a.out doesn't work FIX_ME !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  *  remember to fix the history bug when we expand the env var !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  export test=a_file
    the export cmd prints the env vars sorted and with 'DECLARE -X'
    echo '"'$test'"'    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  * echo "$"HOME
  * echo $99pppl
    sort <<te's't // this should not expand the env vars
    echo -nnnnnnnnnnnnnnnnnnn // ??
  *  echo $ABC $1ABC $ABC1
  *  echo $.ABC
  *  the exit status doesn't return the right int when 'exit 0'
    (ttyname) what if we change the fd of the parent to a non terminal one ? (exec ?)
  *  MEMORY LEAK !!!!!
  *    echo $1try
  export test="'some_file$'"
  echo $test

  minishell : export file_name="'a_file'"
  minishell : echo $file_name
  a_file
  the output should be 'a_file', but we get a_file because we perform variable expansion and then we remove quotes, a possible solution would be to rm quotes first,
   expect for when there's a '$' and then perform variable expansion after that we rm quotes again;

  
    */
-redirection:
    $ > somwhere ls -la
    need to handle the space in the filename as in ls > "some place"
    ~/minishell/old/a.out ????????????????????????????????????????????????????????????????????????????????????????????????????????????????
    ls sdfasfasdf >errortesting 2>&1 
    ls /home/ salfkajsdlfjadslkf &>lllll
    3< lllll
    echo "something else" >&3
    echo testing something to do yeah >'#yo' // works
    echo testing something to do yeah >#yo // gives an error
    echo testing something to do yeah >>>>good
  *  echo testsomethingtdo >b_file somethingelse ????????????? doesn't work
  export test="'somefile'"
  ls /somehwere /home 2f>>a_file >>a_file > $test 2>$test
  echo "testing expansion with spaces" >"$test file"
  ls /somehwere /home > $test 2>$test
  echo "some dumb weird sin" > "'$test in $test'"
  <test_progm.c grep 'test' > b >c >$test >$non
  make a program that opens all 1024 fds; // this won't effect the shell cuz when we run a proram we use fork;
    quotes shenannigas 
        maybe dup the file name and passe to youssef's function that handles quotes ? I assumed this (this won't work cuz the shell doesn't use the same logic) cuz
        // I didn't know that ls adds quotes when it finds a meta charactere on a file/dir name;
    ls /somehwere /home 2f>>a_file >>a_file > f_file 2>f_file
  *  echo testing something 1>"'9991'" ???
  *  echo testing something 1>'9991'   ?!@#!@#?1RF?qeF?sd
  * FIX THE HISTORY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    cat <<EOF>some_file.txt
  * cat << EOF <file.txt>some_file.txt
  ??
  asoufian@c2r4p1:~/minishell$ export EXP='my files'
  asoufian@c2r4p1:~/minishell$ echo "test something to do yeah" >$EXP
  bash: $EXP: ambiguous redirect
  ??
  weird here-doc behaviour:
      asoufian@c2r4p1:~/minishell$ sort << EOF
    > some text
    > $HOME
    > some more text
    > '$HOME'
    > another sentence
    > EOF
    another sentence
    '/home/asoufian'
    /home/asoufian
    some more text
    some text

  exit:
    unsigned char c = n (n is the return of atoi, which byitself is the argument that is given to the exit command)


PIPING:
 echo "somethign to do yeah" | grep to | grep t | sort | wc | cut -f2 -d '1' | awk '{print $2}'





  see how fork and children handle signals

==============================
./minishell < inputs.txt
==============================
























echo $HOME-test 
cat <<EOF <some_file.txt 
  the delimited should be 'EOF' but our minishell takes 'EOF>some_file.txt' as the delimited;

<file.txt <<EOF sort


IF MALLOC FAILS, make a function that will free the struct and exit;

reform/refactor the code; 

STATUS '$?'
make a struct that should include atleast : (for now)
  (char **rdl_args, char ***envp, char **env_paths, int *status, int *s_exit)

SIGNLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS

PIPE,




























