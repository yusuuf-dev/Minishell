// fix old/a.out: executing a file by it's relative path doesn't work if the file is in a dir
// check if the builtin functions work properly
// fix the ~{user} ex: ~asoufian
// make the code more readable, 
// store all the needed variables in a struct
// symbolik links !!!!!!! : CD AND PWD
// echo "test something" needs to be handled
- to get the actual output of a command run 'set -x' to unset it run 'set +x'
/*
export:
variables:
	A word consisting solely of letters, numbers, and underscores, and beginning with a letter or underscore. 
	Names are used as shell variable and function names. Also referred to as an identifier.
    also look up if the x-declare in the export means anything
    if I readonly an env variable it becomes declare -rx in the export 
  maybe I should remove the variable '_' since the minishell doesn't update it and the bash doesn't seem to give it the 'x' attribute
  export --help, what does 'export --' do ??

revisit all built-in functions !!!!!!!!!!!
*/
/* Parsing:
    handle the '#' as in echo #test .... : MAYBE ??????????????????????????????????????????????????
    the shell ignores the comment symbol (â€˜#â€™), and the rest of that line. */
    /*minishell : export test=something
    minishell : echo testing$test
    testing$test
    echo "$PATH"test
    echo $'\n'
    x=-n
    echo $x $PATH $: /home/asoufian/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin%
  *  old/a.out doesn't work FIX_ME !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  *  remember to fix the history bug when we expand the env var !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  export test=a_file
    the export cmd prints the env vars sorted and with 'DECLARE -X'
    echo '"'$test'"'    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  * echo "$"HOME
  * echo $99pppl
    sort <<te's't // this should not expand the env vars
    echo -nnnnnnnnnnnnnnnnnnn // ??
  *  echo $ABC $1ABC $ABC1
  *  echo $.ABC
  *  the exit status doesn't return the right int when 'exit 0'
    (ttyname) what if we change the fd of the parent to a non terminal one ? (exec ?)
  *  MEMORY LEAK !!!!!
  *    echo $1try
  export test="'some_file$'"
  echo $test

  minishell : export file_name="'a_file'"
  minishell : echo $file_name
  a_file
  the output should be 'a_file', but we get a_file because we perform variable expansion and then we remove quotes, a possible solution would be to rm quotes first,
   expect for when there's a '$' and then perform variable expansion after that we rm quotes again;

  
    */
-redirection:
    $ > somwhere ls -la
    need to handle the space in the filename as in ls > "some place"
    ~/minishell/old/a.out ????????????????????????????????????????????????????????????????????????????????????????????????????????????????
    ls sdfasfasdf >errortesting 2>&1 
    ls /home/ salfkajsdlfjadslkf &>lllll
    3< lllll
    echo "something else" >&3
    echo testing something to do yeah >'#yo' // works
    echo testing something to do yeah >#yo // gives an error
    echo testing something to do yeah >>>>good
  *  echo testsomethingtdo >b_file somethingelse ????????????? doesn't work
  export test="'somefile'"
  ls /somehwere /home 2f>>a_file >>a_file > $test 2>$test
  echo "testing expansion with spaces" >"$test file"
  ls /somehwere /home > $test 2>$test
  echo "some dumb weird sin" > "'$test in $test'"
  <test_progm.c grep 'test' > b >c >$test >$non
  make a program that opens all 1024 fds; // this won't effect the shell cuz when we run a proram we use fork;
    quotes shenannigas 
        maybe dup the file name and passe to youssef's function that handles quotes ? I assumed this (this won't work cuz the shell doesn't use the same logic) cuz
        // I didn't know that ls adds quotes when it finds a meta charactere on a file/dir name;
    ls /somehwere /home 2f>>a_file >>a_file > f_file 2>f_file
  *  echo testing something 1>"'9991'" ???
  *  echo testing something 1>'9991'   ?!@#!@#?1RF?qeF?sd
  * FIX THE HISTORY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    cat <<EOF>some_file.txt
  * cat << EOF <file.txt>some_file.txt
  ??
  asoufian@c2r4p1:~/minishell$ export EXP='my files'
  asoufian@c2r4p1:~/minishell$ echo "test something to do yeah" >$EXP
  bash: $EXP: ambiguous redirect
  ??
  weird here-doc behaviour:
      asoufian@c2r4p1:~/minishell$ sort << EOF
    > some text
    > $HOME
    > some more text
    > '$HOME'
    > another sentence
    > EOF
    another sentence
    '/home/asoufian'
    /home/asoufian
    some more text
    some text

  exit:
    unsigned char c = n (n is the return of atoi, which byitself is the argument that is given to the exit command)


PIPING:
 echo "somethign to do yeah" | grep to | grep t | sort | wc | cut -f2 -d '1' | awk '{print $2}'





  see how fork and children handle signals

==============================
./minishell < inputs.txt
==============================








echo $HOME-test 
cat <<EOF <some_file.txt 
  the delimited should be 'EOF' but our minishell takes 'EOF>some_file.txt' as the delimited;

<file.txt <<EOF sort


IF MALLOC FAILS, make a function that will free the struct and exit;

reform/refactor the code; 

STATUS '$?'
make a struct that should include atleast : (for now)
  (char **rdl_args, char ***envp, char **env_paths, int *status, int *s_exit)


SIGNLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS
PIPE, the exit status is wrong, 
probably need to make the pipe forks 2 child and write and read from the pipe simultaneously, cuz if the program only write to the pipe and it reaches the max PIPE_CAPACITY
it will hang, meaning It's waiting for the pipe to be read so the buffer will get freed ???.
free the memory that's left in the child !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
bugged:  echo hola | cat | cat | cat | cat | cat | grep hola ???

echo "something to do yeah" | grep test
echo "something to do yeah" | grep yeah | wc -l
echo "something to do yeah" | grep yeah
echo "something to do yeah" | grep yeah | wc -l
echo "something to do yeah" | grep yeah
echo "something to do yeah" | grep test
echo "something to do yeah" | grep yeah | wc -l

https://docs.google.com/spreadsheets/u/0/d/1uJHQu0VPsjjBkR4hxOeCMEt3AOM1Hp_SmUzPFhAH-nA/htmlview?lsrp=1

export: *234, 238, 272, *273, 294(youssef), 296, 298, 305(youssef ?), 306, 311, 312, 313, 314 (segfault), 327, 328, 330, 
cd: 440, 


script:
-skipped:
'export HO#LA', cuz I use the # as a delimiter when I want to split the commands using 'tr'
'export ""', dunno how this gets parsed
'export HOLA=bon\;jour' : sepcial charactere "\;"
'export HOLA=bon!jour' : special charactere "!"
313 so far;
'export HOLA=bonjour BYE=casse-toi#echo $?#echo $HOLA et $BYE#echo $?#export $HOLA=bonjour#echo $?#env | grep bonjour#echo $?#export | grep bonjour#echo $?'
when I run the above line there's a difference in which the bash and minishell sorts the bonjour and HOLA env var in env, maybe It's fine ?
Need to change ALL calls to the printf function in the minishell to ft_putstr or write  


exec 1<&- :x

exit 234 2342 56456 : this shouldn't exit
exit fff 2342 56456 : this should exit

exit 222 ffff 56456 : this shouldn't exit

exit "     
 00010"

pwd shenanigans, use a char *p to store the pwd, instead of calling getcwd each time ? 

try send SIGINT signal by Ctr + c, while running another program in minishell, such as (find, ping....)

remember to use unlink in heredoc
  to make the heredoc exit with Ctr^c
  we need to fork and restart the signal handler to it's DFL
  function: searchs for heredoc in entered cmd, fork, restore SIGINT to SIG_DFL, done ?
  echo aye | echo omsething | sort << EOF | echo nay ???????????????
static function that frees the struct ?? / freeing(void *p); if (p) ; static void *ptr = p
If I run a minishell within minishell (calling minishell by another minishell) and used a command such as (ls,....) something that requires fork and execve,
will the first minishell also get woken up (meaning exiting the wait status) cuz the ran command 'ls' will send a SIGCHILD to that second one.????


cat <minishell.h <<HERE <missing <<DOC | echo oi


#invalid command, followed by empty variable, should clear the exit code
doesntexist
$EMPTY
echo $?

execute permission with sudo, the loop should keep going, 

minishell : cat << jjj
> jhjhjk
> kjhjkhkj
> '$USER'
> jjj


# Neither of these unsets should break the shell, and you should still be able to call `/bin/ls`
unset USER
unset PATH
unset PWD
/bin/ls


753_ cat << : should give an error
757_ << $"hola"$"b" the heredoc should exit with holab
758_ << $"$hola"$$"b" the heredoc should exit with $hola$$b

119/146
121/146

note that we can use the global variable __environ instead of specifying the envp in each function;
look into interactive mode in bash

read man of exit function
maybe we don't need to check for error returns with signal/sigaction functions

remember to remove the syntax checking inside : pipe/redirection parsing part, since we have check_syntax function that does that in the beginning

if (pfd[1] != STDOUT_FILENO) {
 dup2(pfd[1], STDOUT_FILENO);
 close(pfd[1]);
}


WHY IS ERRNO 2 ????????????????????????????????????????????????????????????
  the access function checks, if a file exits in the loop of PATH to execute a cmd
try spam-send SIGQUIT to minishell and see what happens.


check if a child causes memory leak in the pipe when we use a built-in cmd (echo, pwd, cd, etc..) !!!!!!!!!!!!!!!!!!!!!!!!  

handle SIGINT in heredoc, cancel the promot by setting a condition check for errno after the readline (it returns an errno);

96 in 42 minishell tester
151 error the redirection doesn't get applied:
  ls|cat Makefile|cat<<asd>out
261 in unset PATH 2_correction.sh:
  It seems that bash tries to execute the file if the PATH is unset ???

 maybe we should move the syntax checking into the parsing part ?
>| echo sure

redirection :
  >> "$H"OM"E"

31/05/2025
ðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸ
ðŸ                                    RESULT                                    ðŸ
ðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸ
             TOTAL TEST COUNT: 941  TESTS PASSED: 836  LEAKING: 0 
                     STD_OUT: 82  STD_ERR: 35  EXIT_CODE: 46  
                         TOTAL FAILED AND PASSED CASES:
                                     âŒ 163   
                                     âœ… 2660  
                                    âŒ 203   
                                     âœ… 262

ðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸ
ðŸ                                    RESULT                                    ðŸ
ðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸðŸ
             TOTAL TEST COUNT: 941  TESTS PASSED: 858  LEAKING: 0 
                     STD_OUT: 62  STD_ERR: 22  EXIT_CODE: 27  
                         TOTAL FAILED AND PASSED CASES:
                                     âŒ 111   
                                     âœ… 2712   

this doesn.t work correctely >> ls|cat Makefile|cat<<asd>out
but this works               >> ls|cat Makefile|cat<<asd >out



00001011
11110100
00001011

11110011

00001100
11110011

00001100

11110100


11110011
11110100

00001011
00001100

restore old frees on the built-in cmds, and the other places too in the minishell, make a function that will free the node which it stores the ptr to the allocated
block so that 'config_malloc' won't cause double free error


minishell : export a="a   b"
minishell : > $a

memory leak on the child:
minishell : << hola
> "hola"
> 'hola'
> hla
> hola

ls | cat << stop >

""
minishell : export X="  A  B  "
minishell : /bin/echo ?$X'2'

tests num: 440, and check error printing if It's correct
